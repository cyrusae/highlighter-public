"use strict";
// Copyright 2020 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJSApi = exports.getDartSassEmbedded = exports.getEmbeddedProtocol = void 0;
const extractZip = require("extract-zip");
const fs_1 = require("fs");
const node_fetch_1 = require("node-fetch");
const p = require("path");
const shell = require("shelljs");
const tar_1 = require("tar");
const pkg = require("../package.json");
shell.config.fatal = true;
// The current platform's operating system. Throws if the operating system
// is not supported by Dart Sass Embedded.
const OS = (() => {
    switch (process.platform) {
        case 'linux':
            return 'linux';
        case 'darwin':
            return 'macos';
        case 'win32':
            return 'windows';
        default:
            throw Error(`Platform ${process.platform} is not supported.`);
    }
})();
// The current platform's architecture. Throws if the architecture is not
// supported by Dart Sass Embedded.
const ARCH = (() => {
    switch (process.arch) {
        case 'ia32':
            return 'ia32';
        case 'x86':
            return 'ia32';
        case 'x64':
            return 'x64';
        case 'arm64':
            return 'arm64';
        default:
            throw Error(`Architecure ${process.arch} is not supported.`);
    }
})();
// The current platform's file extension for archives.
const ARCHIVE_EXTENSION = OS === 'windows' ? '.zip' : '.tar.gz';
// Directory that holds source files.
const BUILD_PATH = 'build';
/**
 * Gets the Embedded Protocol.
 *
 * Can download the release `version`, check out and build the source from a Git
 * `ref`, or build from the source at `path`.
 *
 * By default, downloads the release version specified in package.json. Throws
 * if an error occurs.
 */
async function getEmbeddedProtocol(outPath, options) {
    const repo = 'embedded-protocol';
    options !== null && options !== void 0 ? options : (options = defaultVersionOption('protocol-version'));
    if ('version' in options) {
        const version = options === null || options === void 0 ? void 0 : options.version;
        await downloadRelease({
            repo,
            assetUrl: `https://github.com/sass/${repo}/archive/${version}${ARCHIVE_EXTENSION}`,
            outPath: BUILD_PATH,
        });
        fs_1.promises.rename(p.join(BUILD_PATH, `${repo}-${version}`), p.join(BUILD_PATH, repo));
    }
    else if ('ref' in options) {
        fetchRepo({
            repo,
            outPath: BUILD_PATH,
            ref: options.ref,
        });
    }
    const source = options && 'path' in options ? options.path : p.join(BUILD_PATH, repo);
    buildEmbeddedProtocol(source);
    await link(source, p.join(outPath, repo));
}
exports.getEmbeddedProtocol = getEmbeddedProtocol;
/**
 * Gets the Dart Sass wrapper for the Embedded Compiler.
 *
 * Can download the release `version`, check out and build the source from a Git
 * `ref`, or build from the source at `path`.
 *
 * By default, downloads the release version specified in package.json. Throws
 * if an error occurs.
 */
async function getDartSassEmbedded(outPath, options) {
    const repo = 'dart-sass-embedded';
    options !== null && options !== void 0 ? options : (options = defaultVersionOption('compiler-version'));
    if ('version' in options) {
        const version = options === null || options === void 0 ? void 0 : options.version;
        await downloadRelease({
            repo,
            assetUrl: `https://github.com/sass/${repo}/releases/download/` +
                `${version}/sass_embedded-${version}-` +
                `${OS}-${ARCH}${ARCHIVE_EXTENSION}`,
            outPath,
        });
        fs_1.promises.rename(p.join(outPath, 'sass_embedded'), p.join(outPath, repo));
        return;
    }
    if ('ref' in options) {
        fetchRepo({
            repo,
            outPath: BUILD_PATH,
            ref: options.ref,
        });
    }
    const source = 'path' in options ? options.path : p.join(BUILD_PATH, repo);
    buildDartSassEmbedded(source);
    await link(p.join(source, 'build'), p.join(outPath, repo));
}
exports.getDartSassEmbedded = getDartSassEmbedded;
/**
 * Checks out JS API type defintions from the Sass language repo.
 *
 * Can check out a Git `ref`, or link to the source at `path`. By default,
 * checks out the latest revision from GitHub.
 */
async function getJSApi(outPath, options) {
    var _a;
    const repo = 'sass';
    let source;
    if (!options || 'ref' in options) {
        fetchRepo({
            repo,
            outPath: BUILD_PATH,
            ref: (_a = options === null || options === void 0 ? void 0 : options.ref) !== null && _a !== void 0 ? _a : 'main',
        });
        source = p.join(BUILD_PATH, repo);
    }
    else {
        source = options.path;
    }
    await link(p.join(source, 'js-api-doc'), p.join(outPath, repo));
}
exports.getJSApi = getJSApi;
// Downloads the release for `repo` located at `assetUrl`, then unzips it into
// `outPath`.
async function downloadRelease(options) {
    console.log(`Downloading ${options.repo} release asset.`);
    const response = await (0, node_fetch_1.default)(options.assetUrl, {
        redirect: 'follow',
    });
    if (!response.ok) {
        throw Error(`Failed to download ${options.repo} release asset: ${response.statusText}`);
    }
    const releaseAsset = await response.buffer();
    console.log(`Unzipping ${options.repo} release asset to ${options.outPath}.`);
    await cleanDir(p.join(options.outPath, options.repo));
    const zippedAssetPath = `${options.outPath}/${options.repo}${ARCHIVE_EXTENSION}`;
    await fs_1.promises.writeFile(zippedAssetPath, releaseAsset);
    if (OS === 'windows') {
        await extractZip(zippedAssetPath, {
            dir: p.join(process.cwd(), options.outPath),
        });
    }
    else {
        (0, tar_1.extract)({
            file: zippedAssetPath,
            cwd: options.outPath,
            sync: true,
        });
    }
    await fs_1.promises.unlink(zippedAssetPath);
}
// Clones `repo` into `outPath`, then checks out the given Git `ref`.
function fetchRepo(options) {
    if (!(0, fs_1.existsSync)(p.join(options.outPath, options.repo))) {
        console.log(`Cloning ${options.repo} into ${options.outPath}.`);
        shell.exec(`git clone \
      --depth=1 \
      https://github.com/sass/${options.repo} \
      ${p.join(options.outPath, options.repo)}`, { silent: true });
    }
    const version = options.ref === 'main' ? 'latest update' : `commit ${options.ref}`;
    console.log(`Fetching ${version} for ${options.repo}.`);
    shell.exec(`git fetch --depth=1 origin ${options.ref} && git reset --hard FETCH_HEAD`, {
        silent: true,
        cwd: p.join(options.outPath, options.repo),
    });
}
// Builds the embedded proto at `repoPath` into a pbjs with TS declaration file.
function buildEmbeddedProtocol(repoPath) {
    const proto = p.join(repoPath, 'embedded_sass.proto');
    console.log(`Building pbjs and TS declaration file from ${proto}.`);
    const protocPath = OS === 'windows'
        ? '%CD%/node_modules/protoc/protoc/bin/protoc.exe'
        : 'node_modules/protoc/protoc/bin/protoc';
    const pluginPath = OS === 'windows'
        ? '%CD%/node_modules/.bin/protoc-gen-ts.cmd'
        : 'node_modules/.bin/protoc-gen-ts';
    shell.exec(`${protocPath} \
      --plugin="protoc-gen-ts=${pluginPath}" \
      --js_out="import_style=commonjs,binary:." \
      --ts_out="." \
      ${proto}`, { silent: true });
}
// Builds the Embedded Dart Sass executable from the source at `repoPath`.
function buildDartSassEmbedded(repoPath) {
    console.log('Downloading dart-sass-embedded dependencies.');
    shell.exec('dart pub upgrade', {
        cwd: repoPath,
        silent: true,
    });
    console.log('Building dart-sass-embedded executable.');
    shell.exec('dart run grinder protobuf pkg-standalone-dev', {
        cwd: repoPath,
        silent: true,
    });
}
// Given the name of a field in `package.json`, returns the default version
// option described by that field.
function defaultVersionOption(pkgField) {
    const version = pkg[pkgField];
    return version.endsWith('-dev') ? { ref: 'main' } : { version };
}
// Links or copies the contents of `source` into `destination`.
async function link(source, destination) {
    await cleanDir(destination);
    if (OS === 'windows') {
        console.log(`Copying ${source} into ${destination}.`);
        shell.cp('-R', source, destination);
    }
    else {
        console.log(`Linking ${source} into ${destination}.`);
        // Symlinking doesn't play nice with Jasmine's test globbing on Windows.
        fs_1.promises.symlink(p.resolve(source), destination);
    }
}
// Ensures that `dir` does not exist, but its parent directory does.
async function cleanDir(dir) {
    await fs_1.promises.mkdir(p.dirname(dir), { recursive: true });
    try {
        await fs_1.promises.rmdir(dir, { recursive: true });
    }
    catch (_) {
        // If dir doesn't exist yet, that's fine.
    }
}
//# sourceMappingURL=utils.js.map