So:
```
router.put('/seen', async (req, res, next) => {
  const { statementID, content } = req.body;
  const statement = await prisma.statement.update(
  {
  where: {
    statementID: statementID
  },
  data: {
    coded: true,
    content: content,
  }
  }
  ) 
  res.json(statement)
  next()
})

router.post('/seen', async (req, res, next) => {
  const { phrase, codeUsed, statementID } = req.body
  const coding = await prisma.encoding.create({
    data: {
      phrase: phrase,
      codeUsed: codeUsed,
      parent: {
        connect: [{ parent: statementID }] 
      }
    },
  }  )
  res.json(coding)
})
```
This is for later, as I try to understand how to update the database with a) new statement content and b) the new encoding for the statement, with the relevant relational link.

For now, `create` is preventing the backend from running, because it's a huge dick. (Would plain `parent: statementID` work?)

Go to next unseen as...?

```
const statement = await prisma.statement.findFirst({
  where: {
    coded: false
  }
})
res.json(statement)
```
To get info about encodings (display list):
```
include: {
  encoding: true
}
```
[How many things should I be using Prisma middleware for instead of Express middleware?](https://www.prisma.io/docs/concepts/components/prisma-client/middleware)

---

## Things to want in the interface:

- Toggle details for seeing what phrases have been applied to the document with what code (default hidden)
- Toggle details for reminder text of keybinding commands (default hidden?)
- Toggle details for reminder of code colors (default open?)
- Toggle details for viewing metadata of statement (default open?)
- Statement body with relevant edits
- Dropdown for selecting code once text has been highlighted
- Button to commit code choice
- Navigation menu: previous statement, next statement, flag statement for additional review, save to quit 
- Details toggle (default closed) to show flagged IDs for this session?

(Also, interface for comments when there's comments: one big one for the full statement, imitate the [key quote generator](https://github.com/chrisdavidmills/selection-api-examples/blob/master/keyquote.js) to create boxes for each individual highlight as they're created but have them be appended to a group generated from the existing ones first)

#### When I can get `index.tsx` proper to myself: 

- Link to the viewing by unreads interface
- Link to the view all interface 
- Direct link to last unread statement (if there is one, if not gray out? Can I do that?) in reader view 
- Direct link to most recently seen statement (may be easiest way to do updates? first means I need to add update dates)

Open issue: **how to handle paragraph breaks in free text answers?**

Coward's answer: assume a negligible amount of people did that and hand-edit as needed until I find something better to do 

---

### Cool things to be able to sort by (any combination of)

- All statements in response to a specific stimulus [use params]
- All statements that are about a specific characteristic (i.e. by question ID agnostic of stimulus ID) [use params]
- All statements I haven't coded yet [use true/false]
- All statements I *have* coded already but want to look upon my works about [use true/false]
- All statements where a specific code was (or wasn't) used [use params]

---

### What do the tables that highlighter uses need to have? 

Prisma *can* get relations, so I should be able to selectively fetch metadata from other tables through the statement ID.

#### Statement table:

- Statement ID 
- Statement text (copy for editing in HTML; probably going to handle creating that via SQL on my own)
- Coded y/n (defaults to false, push update on first encoding)
- Date updated (which I need to remake the dummy database to be able to do)
- Question ID [may be via FK]
- Stimulus ID [may be via FK]
- Respondent ID [may be via FK]
- Link to encodings
- Number and list of codes used (generated by relation to encodings)
- Comments (eventually, when that's implemented)

#### Encodings table:

- Phrase (plain text)
- Phrase ID
- Parent stimulus and all that implies 
- Code applied to phrase

#### Codes table:

- ID of code for dropdown and CSS
- Human-readable short name of code
- Sentence-long gloss of meaning of code 
- Color code of code 

(Use code table to a) generate quickref table, b) I was going to say generate CSS for embedding them back into the page but I guess that's down to class names.)

**To do:** Determine best way to handle potential overlapping encodings (other than, for now, that I'm not doing that)

Side note: I'm probably generating excess IDs compared to things that would be more elegant using a unique limitation based on a combination of fields, *but* it increases portability and decreases association between a participant and their answers across tables that I wouldn't have to look up with more effort, so I think it's okay 

---

### Thought on CSS:

- Can I pull off using [`@else` in Sass](https://sass-lang.com/documentation/at-rules/control/each) to generate the mark CSS?

Even if I can't get the backend to talk to the frontend about it (surely there's a way? Probably a future problem though), something like
```
mark {
  font-family: 'Victor Mono', Consolas;
  font-style: italic;
}

@use "sass:map"

/* have a map of codes */
$codes:
  ("code_1": #ff0000,  "code_2": #00ff00,  "code_3": #0000ff);

/* create a class for each one */
@each $code, $color in $codes {
  mark#{$code} {
    background: $color !important;
  }
}
```
is still easier to do that way with an exported list from the database that I update by hand.

But also surely there's a secret way to not be like that? The CSS is part of the frontend, it should be able to do this, dang it.

Side note: Might be able to nest the `mark` more elegantly with [something like this](https://stackoverflow.com/questions/40310589/each-with-an-include-mixin) but if it's all compiling to CSS anyway I guess it's not that big of deal to not have my SCSS be nested perfectly.